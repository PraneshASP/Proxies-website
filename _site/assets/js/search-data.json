{"0": {
    "doc": "Delegatecall with Selfdestruct",
    "title": "Delegatecall with Selfdestruct",
    "content": "There are unexpected edge cases when delegatecall and selfdestruct are used together. TODO: @devtooligan . ",
    "url": "/docs/Delegatecall-with-selfdestruct/",
    "relUrl": "/docs/Delegatecall-with-selfdestruct/"
  },"1": {
    "doc": "Developer's Guide to Proxies",
    "title": "Developer's Guide to Proxies",
    "content": "Choosing the right proxy to use for your contract is hard, so we tried to make your life easier with this guide. TODO: @devtooligan . ",
    "url": "/docs/Dev_Guide/",
    "relUrl": "/docs/Dev_Guide/"
  },"2": {
    "doc": "Full List of Proxy Types",
    "title": "Table of contents",
    "content": ". | The Proxy . | Use cases | Pros | Cons | Examples | Known vulnerabilities | Variations | Further reading | . | The Initializeable Proxy . | Use cases | Pros | Cons | Examples | Known vulnerabilities | Variations | Further reading | . | The Upgradeable Proxy . | Use cases | Pros | Cons | Examples | Known vulnerabilities | Further reading | . | EIP-1967 Upgradeable Proxy . | Use cases | Pros | Cons | Examples | Known vulnerabilities | Further reading | . | The Proxy Delegate | Transparent Proxy (TPP) . | Use cases | Pros | Cons | Examples | Known vulnerabilities | Further reading | . | Universal Upgradeable Proxy Standard (UUPS) . | Use cases | Pros | Cons | Examples | Known vulnerabilities | Further reading | . | Beacon Proxy . | Contract Verification | Use cases | Pros | Cons | Examples | Known vulnerabilities | Variations | Further reading | . | Diamond Proxy . | Contract Verification | Use cases | Pros | Cons | Examples | Known vulnerabilities | Variations | Further reading | . | Metamorphic Contracts . | Contract Verification | Use cases | Pros | Cons | Examples | Known vulnerabilities | Further reading | . | . ",
    "url": "/docs/Proxies-List/#table-of-contents",
    "relUrl": "/docs/Proxies-List/#table-of-contents"
  },"3": {
    "doc": "Full List of Proxy Types",
    "title": "The Proxy",
    "content": "And Vitalik said, “Let there be Proxies!” . The proxy itself is not inherantly upgradeable, but it is the basis for just about all upgradeable proxy patterns. Calls made to the proxy contract are forwarded to the implementation contract using delegatecall. In some variants, calls to the proxy are only forwarded if the caller matches an “owner” address. Implementation address - Immutable in the proxy contract. Upgrade logic - There is no upgradeability in a pure proxy contract. Contract verification - Works with Etherscan (example) and other block explorers. Use cases . | Useful when there is a need to deploy multiple contracts whose code is more or less the same. | . Pros . | Inexpensive deployment. | . Cons . | Adds a single delegatecall cost to each call. | . Examples . | Uniswap V1 AMM pools | Synthetix | . Known vulnerabilities . | Delegatecall not allowed in implementation | . Variations . | The EIP-1167 standard was created in June ‘18 with the goal of standardizing a way to clone contract functionality simply, cheaply, and in an immutable way. This standard contains a minimal bytecode redirect implementation that has been optimized for the proxy contract. This is often used with a factory pattern. | . Further reading . | A Minimal Proxy in the Wild | OpenZeppelin core Proxy contract | Deep dive into the Minimal Proxy contract | . ",
    "url": "/docs/Proxies-List/#the-proxy",
    "relUrl": "/docs/Proxies-List/#the-proxy"
  },"4": {
    "doc": "Full List of Proxy Types",
    "title": "The Initializeable Proxy",
    "content": "“But what are we supposed to do without a constructor()?” . Most modern day proxies are initializeable. One of the main benefits of using a proxy is that you only have to deploy the implementation contract once, and then you can deploy many proxy contracts that point at it. However, the downside to this is that you cannot use a constructor in the already deployed implementaion contract when creating the new proxy. Instead, an initialize() function is used to set initial storage values: . uint8 private _initialized; function initializer() external { require(msg.sender == owner); require(_initialized &lt; 1); _initialized = 1; // set some state vars // do initialization stuff } . Use cases . | Most proxies with any kind of storage that needs to be set upon proxy contract deployment. | . Pros . | Allows initial storage to be set at time of new proxy deployment. | . Cons . | Susceptible to attacks related to initialization, especially uninitialized proxies. | . Examples . | This feature is used with most modern proxy types including TPP and UUPS, except for use cases where there is no need to set storage upon proxy deployment. | . Known vulnerabilities . | Uninitialized proxy | . Variations . | Clone factory contract model - uses clone initialization in a creation transaction. | Clones with Immutable Args - enables creating clone contracts with immutable arguments which are stored in the code region of the proxy contract. When called, arguments are appended to the calldata of the delegatecall, Implementation contract function then reads the arguments from calldata. This pattern can remove the need to use an intializer but the downside is that currently the contract cannot be verified on Etherscan. | . Further reading . | The First Proxy Contract | Writing Upgradeable Contracts | . ",
    "url": "/docs/Proxies-List/#the-initializeable-proxy",
    "relUrl": "/docs/Proxies-List/#the-initializeable-proxy"
  },"5": {
    "doc": "Full List of Proxy Types",
    "title": "The Upgradeable Proxy",
    "content": "And the people said, “But we want to upgrade our immutable contracts!” . The Upgradeable Proxy is similar to a Proxy, except the implementation contract address is settable and kept in storage in the proxy contract. The proxy contract also contains permissioned upgrade functions. One of the first upgradeable proxy contracts was written by Nick Johnson in 2016. For security, it is also recommended to use a form of access control to differentiate between the owner/caller and the admin with permission to upgrade the contract. Implementation address - Located in proxy storage. Upgrade logic - Located in the proxy contract. Contract verification - Depending on the exact implementation, it may not work with block explorers like Etherscan. Use cases . | A minimalistic upgrade contract. Useful for learning projects. | . Pros . | Reduced deployment costs through use of the Proxy. | Implementation contract is upgradeable. | . Cons . | Prone to storage and function collisions. | Less secure than modern counterparts. | Every call incurs cost of delegatecall from the Proxy. | . Examples . | This basic style is not widely used anymore. | . Known vulnerabilities . | Delegatecall not allowed in implementation | Uninitialized proxy | Storage collision | Function collision | . Further reading . | The First Proxy Contract | Writing Upgradeable Contracts | . ",
    "url": "/docs/Proxies-List/#the-upgradeable-proxy",
    "relUrl": "/docs/Proxies-List/#the-upgradeable-proxy"
  },"6": {
    "doc": "Full List of Proxy Types",
    "title": "EIP-1967 Upgradeable Proxy",
    "content": "The “solution” to storage collisions . This is similar to the Upgradeable Proxy, except that it reduces risk of storage collision by using the unstructured storage pattern. It does not store the implementation contract address in slot 0 or any other standard storage slot. Instead the address is stored in a pre-agreed upon slot (for example 0x360894…ca505d382bbc in OpenZeppelin contracts) which has the added benefit of allowing block explorers to verify the contracts and properly show this information to end users. EIP-1967 also specifies a slot for admin storage (auth) as well as Beacon Proxies which will be discussed in detail below. Implementation address - Located in a unique storage slot in the proxy contract. Upgrade logic - Varies based on implementation. Contract verification - Yes, most evm block explorers support it. Use cases . | When you need more security than the basic Upgradeable Proxy. | . Pros . | Reduces risk of storage collisions. | Block explorer compatibility | . Cons . | Susceptible to function collisions. | Less secure than modern counterparts. | Every call incurs cost of delegatecall from the Proxy. | . Examples . | While the EIP-1967 storage slot pattern has been widely adopted in most modern upgradeable proxy types, this bare bones contract is not seen in the wild as much as some of the newer patterns like Beacon, TPP and UUPS. | . Known vulnerabilities . | Uninitialized proxy | Function collision | . Further reading . | EIP-1967 Standard Proxy Storage Slots | ",
    "url": "/docs/Proxies-List/#eip-1967-upgradeable-proxy",
    "relUrl": "/docs/Proxies-List/#eip-1967-upgradeable-proxy"
  },"7": {
    "doc": "Full List of Proxy Types",
    "title": "The Proxy Delegate",
    "content": "| . ",
    "url": "/docs/Proxies-List/#the-proxy-delegate",
    "relUrl": "/docs/Proxies-List/#the-proxy-delegate"
  },"8": {
    "doc": "Full List of Proxy Types",
    "title": "Transparent Proxy (TPP)",
    "content": "The “solution” to function collisions . This is similar to the Upgradeable Proxy and usually incorporates EIP-1967, but when the permissioned functions are called, if admin is the caller then those functions are invoked directly on the proxy, otherwise the call is forwarded to the implementation contract. This is often implemented with a modifier like this one from OpenZeppelin: . modifier ifAdmin() { if (msg.sender == _getAdmin()) { _; } else { _fallback(); // redirects call to proxy } } . Implementation address - Located in a unique storage slot in the proxy contract (EIP-1967). Upgrade logic - Located in the proxy contract with use of a modifier to re-route non-admin callers. Contract verification - Yes, most evm block explorers support it. Use cases . | This pattern is very widely used for its upgradeability and protections against certain function and storage collision vulnerabilities. | . Pros . | Block explorer compatibility. | Reduces risk of function collisions due to ifAdmin() modifier. | Reduces risk of storage collisions from use of EIP-1967 storage slots. | . Cons . | Considered by some to be less secure than UUPS. | Every call incurs cost of delegatecall from the Proxy. | . Examples . | dYdX | USDC | Aztec | Hundreds of projects on Github | . Known vulnerabilities . | Delegatecall not allowed in implementation | Uninitialized proxy | Storage collision | . Further reading . | The Transparent Proxy Pattern | . ",
    "url": "/docs/Proxies-List/#transparent-proxy-tpp",
    "relUrl": "/docs/Proxies-List/#transparent-proxy-tpp"
  },"9": {
    "doc": "Full List of Proxy Types",
    "title": "Universal Upgradeable Proxy Standard (UUPS)",
    "content": "What if we move the upgrade logic to the impl contract? 🤔 . EIP-1822 describes a standard for an upgradeable proxy pattern where the upgrade logic is stored in the implementation contract. This way, there is no need to check if the caller is admin in the proxy (saving gas) at the proxy level, saving gas. It also eliminates the possibility of a function on the implementation contract colliding with the upgrade logic in the proxy. The UUPS proxy also contains a check when upgrading that ensures the new implementation contract is upgradeable. This proxy contract usually incorporates EIP-1967. Implementation address - Located in a unique storage slot in the proxy contract (EIP-1967). Upgrade logic - Located in the implementation contract. Contract verification - Yes, most evm block explorers support it. Use cases . | These days this is the most widely used pattern when protocols look to deploy upgradeable contracts. | . Pros . | Eliminates risk of functions on the implementation contract colliding with the proxy contract since that logic lives on the implementation contract. | Reduces risk of storage collisions from use of EIP-1967 storage slots. | . Cons . | Somewhat more complex and more overhead than other proxy types. | Every call incurs cost of delegatecall from the Proxy. | . Examples . | Superfluid | Synthetix | Hundreds of projects on Github | . Known vulnerabilities . | Uninitialized proxy | Function collision | Selfdestruct | . Further reading . | EIP-1822 | Using UUPS Proxy Pattern | Perma-brick UUPS proxies with this one trick | . ",
    "url": "/docs/Proxies-List/#universal-upgradeable-proxy-standard-uups",
    "relUrl": "/docs/Proxies-List/#universal-upgradeable-proxy-standard-uups"
  },"10": {
    "doc": "Full List of Proxy Types",
    "title": "Beacon Proxy",
    "content": "Is that a beacon in your proxy or are you just happy to see me? 🤔 . Most proxies discussed so far store the implementation contract address in the proxy contract storage. The Beacon pattern, popularized by Dharma in 2019, stores the address of the implementation contract in a separate “beacon” contract. The address of the beacon is stored in the proxy contract. To save gas, the proxy often stores the beacon address immutably. With other types of proxies, when the implementation contract is upgraded, all of the proxies need to be updated. However, with the Beacon proxy, only the beacon contract itself needs to be updated. EIP-1967 also references a Beacon address slot. Contract Verification . | Yes, most evm block explorers support it. | . Use cases . | If you have a need for multiple proxy contracts that can all be upgraded at once by upgrading the Beacon. | Appropriate for situations that involve large amounts of proxy contracts based on multiple implementation contracts. The beacon proxy pattern enables updating various groups of proxies at the same time. | . Pros . | Easier to upgrade multiple proxy contracts at the same time. | . Cons . | Gas overhead of getting the Beacon contract address from storage, calling Beacon contract, and then getting the implementation contract, plus the extra gas required by using a proxy. | Adds additional complexity. | . Examples . | USDC | Dharma | . Known vulnerabilities . | Uninitialized proxy | Function collision | . Variations . | Storageless Upgradeable Beacon Proxy - In this pattern, the beacon contract does not store the implementation contract address in storage, but instead stores it in code. The proxy contract loads it from the proxy directly via EXTCODECOPY. | . Further reading . | How to create a Beacon Proxy | Dharma | . ",
    "url": "/docs/Proxies-List/#beacon-proxy",
    "relUrl": "/docs/Proxies-List/#beacon-proxy"
  },"11": {
    "doc": "Full List of Proxy Types",
    "title": "Diamond Proxy",
    "content": "“Diamonds are a proxy’s best friend?” . EIP-2535 “Diamonds” are modular smart contract systems that can be upgraded/extended after deployment, and have virtually no size limit. From the EIP: . a diamond is a contract with external functions that are supplied by contracts called facets. Facets are separate, independent contracts that can share internal functions, libraries, and state variables. The diamond pattern consists of a central Diamond.sol proxy contract. In addition to other storage, this contract contains a registry of functions that can be called on external contracts called facets. Glossary of Diamond proxy uses a unique vocabulary: . | Diamond term | Definition | . | Diamond | Proxy | . | Facet | Implementation | . | Cut | Upgrade | . | Loupe | List of delegated functions | . | Finished diamond | Non-upgradeable | . | Single cut diamond | Remove upgradeability functions | . Contract Verification . | Contracts can be verified on Etherscan with the help of a tool called Louper (example). | . Use cases . | A complex system where the highest level of upgradeability and modular interoperability is required. | . Pros . | A stable contract address that provides needed functionality. Emitting events from a single address can simplify event handling. | Can be used to break up a large contract &gt; 24kb that is over the Spurious Dragon limit. | . Cons . | Additional gas required to access storage when routing functions. | Complexity may be too much when simple upgradeability is required. | . Examples . | Simple DeFi | PartyFinance | Complete list of examples. | . Known vulnerabilities . | No known vulnerabilities aside from the general risk associated with implementing patterns with any degree of complexity. | . Variations . | vtable | How to build unlimited size contracts | . Further reading . | Answering some Diamond questions | Dark Forest and the Diamond standard | Good idea, bad design. How the Diamond standard falls short | Addressing Josselin Feist’s Concern’s of EIP-2535 Diamonds | . ",
    "url": "/docs/Proxies-List/#diamond-proxy",
    "relUrl": "/docs/Proxies-List/#diamond-proxy"
  },"12": {
    "doc": "Full List of Proxy Types",
    "title": "Metamorphic Contracts",
    "content": "“create2, use, selfdestruct, rinse, repeat…” . The metamorphic contract is unique from all the other upgradeable patterns in that it does NOT use a proxy. There is no delegatecall to an external logic contract. When it’s time for an upgrade, the metamorphic contract uses selfdestruct and the new contract is deployed to the same address using create2. This can be achieved by having the initcode retrieve the creation code from the storage of a separate external contract. In this way, the initcode will always be the same, and therefore create2 can be used to deploy to the same address. Contract Verification . | Yes, metamorphic contracts can be verified. | . Use cases . | Contracts that contain only logic (similar to Solidity external libraries) | Contracts with little state that changes infrequently, such as beacons. | . Pros . | Does not require the use of a proxy with delegatecall. | Does not require using an initialize() instead of a constructor().` | . Cons . | Storage is erased on upgrade because of selfdestruct. | Because selfdestruct clears the code at the end of the transaction, an upgrade requires two transactions: one to delete the current contract, and another to create the new one. Any transaction that arrives to our contract in between those two would fail. | The selfdestruct opcode may be removed in the future. | . Examples . | This is more of an experimental type. Mostly used by MEV searchers. | . Known vulnerabilities . | Not vulnerable to the typical upgradeable proxy vulnerabilities since it doesn’t use a proxy or an initializer. | May be vulnerable to attack at time of upgrade. | . Further reading . | Metamorphosis Smart Contracts using CREATE2 | The Promise and the Peril of Metamorphic Contracts | . ",
    "url": "/docs/Proxies-List/#metamorphic-contracts",
    "relUrl": "/docs/Proxies-List/#metamorphic-contracts"
  },"13": {
    "doc": "Full List of Proxy Types",
    "title": "Full List of Proxy Types",
    "content": " ",
    "url": "/docs/Proxies-List/",
    "relUrl": "/docs/Proxies-List/"
  },"14": {
    "doc": "Proxies Storage",
    "title": "Proxies Storage",
    "content": "Storage Slot Analysis for Verified Contracts . | slither-read-storage: A slither tool to retrieve storage slots for verified contracts | sol2uml: A visualizer of storage slot usage for a verified contract | Slither unitialized proxy detector: Only can detect race condition vulnerability because slither’s static analyzer is designed for contract code that is not deployed on chain yet | . Storage Slot Analysis for Unverified Contracts . | Contract Library: When viewing a contract, can navigate to the “Read/Write” tab and choose “Storage dump” to see all values stored in all storage slots. Doesn’t require a verified contract. | smart-contract-storage-viewer: Useful tool from tintinweb to view what a contract has stored in storage slots | Etherscan: The “Switch to Opcodes View” button next to the contract creation code and review all the SLOAD operations to identify storage slots storing values | . ",
    "url": "/docs/Proxies-Storage/",
    "relUrl": "/docs/Proxies-Storage/"
  },"15": {
    "doc": "Proxies Table",
    "title": "Proxies Table",
    "content": "| Type | Summary | Pros | Cons | Gotchas | Who should implement | Known Vulnerabilities | Upgradeable? | Can be made immutable? |   | . | Proxy | Calls made to the proxy contract are forwarded to the implementation contract using delegatecall. Address of the implmentation contract is immutable in the proxy. This is the basis for just about all proxy types with the exception of Metamorphic. One example of this proxy type is EIP1167 Minimal Proxy Clones. An improvement over Minimal Proxy Clones is Clones with Immutables | Simple | Costs gas to do the delegate call |   | Shims to avoid deploying many of the same contract | can deploy new shims that poijnt to an existing contract. When there’s a 1-1 relationship between proxy and impl contracts. | delegatecall in impl, or selfdestruct in impl | No | Yes, by design. | . | Upgradeable Proxy | Similar to proxy except the address of the impl contract is kept in storage in the proxy. Permissioned upgrade logic is also located in the proxy. | Simple. | Extra care is required for the upgrade logic (access control) as it resides in the implementation contract. Costs gas to do the delegate call, Vulnerable to function collisions | storage collisions can be avoided by eip1967 , admin != caller | Not widely used anymore. There are better patterns. | Function collision w proxy, storage colliosion, delegatecall in impl, or selfdestruct in impl | Yes | Yes, by admin revoking ownership of the proxy. |   | . | Transparent Proxy (TPP) | Similar to Upgradeable proxy for non-admin callers, but when the admin calls the proxy the proxy’s functions are used | Comparatively easy and simpler to implement; widely used | Waste gas on delegatecall and checking storage to see if caller is admin | storage collisions can be avoided by eip1967 , admin != caller, using a UUPS compliant implementation with a TransparentUpgradeableProxy might allow non-admins to perform upgrade operations | Still used for its simplicity especially when there is a 1:1 relationship between the proxy and impl contracts. | function collision with proxy, delegatecall in impl, or selfdestruct in impl, storage slot collision w proxy, uninitialize proxies, gas guzzler | Yes | Yes, by admin revoking ownership of the proxy. |   | . | Universal Upgradeable Proxy Standard (UUPS) - EIP1822 | Similar to Transparent proxy except the upgrade logic is stored in the implementation contract so there is no need to check if the caller is admin in the proxy (saving gas). UUPS proxies also contain a check to ensure the new impl contract is also upgradeable. | More gas efficient. Reduces function conflicts w proxy since upgrade fns are in impl. | Still havve overhead of delegate call | storage collisions can be avoided by eip1967 , admin != caller | For a more gas efficient proxy and when there are many different proxy contracts pointing to the same implementation. | delegatecall in impl, or selfdestruct in impl, uninitialized proxy | Yes | Yes by admin revoking ownership or by upgrading to an impl contract that does not contain impl logic. |   | . | Beacon Proxy (aka Dharma Beacon Proxy) | Instead of storing the impl contract address | the proxy stores the address of a beacon. The beacon contract stores the address of the implementation contract. | Can upgrade many different proxies pointing to the beacon. | Gas overhead of calling Beacon contract and getting the impl contract address from storage, as well as the delegate call | storage collisions can be avoided by eip1967 , admin != caller | When more control is desired with more complex systems of upgradeability. Sets of proxies can point to one beacon while other types can point to a different beacon. | delegatecall in impl, or selfdestruct in impl, uninitialized proxy | Yes | Technically yes, but if the goal was immutability then choose a different type. | . | Upgradeable Beacon Proxy | Same as Dharma Beacon proxy except the Beacon address is settable in the proxy. | Even the Beacon contract can be upgraded. | Complex. Gas guzzler. | storage collisions can be avoided by eip1967 , admin != caller | Even more complex patterns can be used when the beacon address is also upgradable. | delegatecall in impl, or selfdestruct in impl, uninitialized proxy | Yes | Technically yes, but if the goal was immutability then choose a different type. |   | . | Storageless Upgradeable Beacon Proxy | The Beacon contract stores the implementation contract in the code instead of in storage, saving gas. https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301 | More gas efficient than TPP, UUPS, Dharma Beacon | Complexity. Little to no adoption. | The upgrade process involves self-destructing the beacon so there is a 1 block down time for the beacon. As such a backup beacon is utilized. | This is more of an experiment and there are no known implementations of this in the wild. | delegatecall in impl, or selfdestruct in impl, uninitialized proxy | Yes | Technically yes, but if the goal was immutability then choose a different type. |   | . | Diamond Proxy | An upgradeable proxy pattern in which there are multiple logic contracts (instead of just one) called facets. Additionally, this pattern uses a separate contract for storage. | Can create powerful, modular combinations. Helps to battle the 24KB size limit via modularity; incremental upgradeability | Compexity. Slow adoption. | More complex to implement and maintain; uses new terminologies that can be harder for newcomers to understand; as of this writing, not supported by tools like Etherscan | When you need the control and flexibility offered by having multiple logic contracts or separate storage. | delegatecall in impl, or selfdestruct in impl, uninitialized proxy | Yes | Yes |   | . | Metamorphic Contract | A contract that is deployed with CREATE2 and in the constructor, it retrieves the address for the contract code from the storage of an external registry contract. To upgrade, the contract is selfdestructed. | No delegatecall so this is the most gas efficient. | Complex, little adoption in the wild. | The selfdestruct opcode may be removed in the future. | Optimizooors, those who like living on the edge. | ? | Yes | Yes, by removing self destruct from the upgrade. |   | . ",
    "url": "/docs/Proxies-Table/",
    "relUrl": "/docs/Proxies-Table/"
  },"16": {
    "doc": "Proxy Identification Flowchart",
    "title": "Proxy Identification Flowchart",
    "content": "TODO: @engn33r Proxy identification flowchart . ",
    "url": "/docs/Proxy-Identification/",
    "relUrl": "/docs/Proxy-Identification/"
  },"17": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Uninitialized Proxy",
    "content": "Impacts UUPS proxies because… . ",
    "url": "/docs/Security_Guide/#uninitialized-proxy",
    "relUrl": "/docs/Security_Guide/#uninitialized-proxy"
  },"18": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Bug Bounties",
    "content": ". | Wormhole: https://medium.com/immunefi/wormhole-uninitialized-proxy-bugfix-review-90250c41a43a | Harvest: https://medium.com/immunefi/harvest-finance-uninitialized-proxies-bug-fix-postmortem-ea5c0f7af96b | Teller: https://medium.com/immunefi/teller-bug-fix-postmorten-and-bug-bounty-launch-b3f67a65c5ac | Aave V2: https://blog.trailofbits.com/2020/12/16/breaking-aave-upgradeability/ and https://medium.com/aave/aave-security-newsletter-546bf964689d | . ",
    "url": "/docs/Security_Guide/#bug-bounties",
    "relUrl": "/docs/Security_Guide/#bug-bounties"
  },"19": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Testing procedure",
    "content": "To test for this vuln, you can approach it from angles XYZ . ",
    "url": "/docs/Security_Guide/#testing-procedure",
    "relUrl": "/docs/Security_Guide/#testing-procedure"
  },"20": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "CTF Examples",
    "content": "Coming soon… . ",
    "url": "/docs/Security_Guide/#ctf-examples",
    "relUrl": "/docs/Security_Guide/#ctf-examples"
  },"21": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Storage Collisions",
    "content": "Impacts X because… . ",
    "url": "/docs/Security_Guide/#storage-collisions",
    "relUrl": "/docs/Security_Guide/#storage-collisions"
  },"22": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Hacks",
    "content": ". | https://solidity-by-example.org/hacks/delegatecall/ | https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22 | . ",
    "url": "/docs/Security_Guide/#hacks",
    "relUrl": "/docs/Security_Guide/#hacks"
  },"23": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Testing procedure",
    "content": "To test for this vuln, you can approach it from angles XYZ . ",
    "url": "/docs/Security_Guide/#testing-procedure-1",
    "relUrl": "/docs/Security_Guide/#testing-procedure-1"
  },"24": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "CTF Examples",
    "content": "Coming soon… . ",
    "url": "/docs/Security_Guide/#ctf-examples-1",
    "relUrl": "/docs/Security_Guide/#ctf-examples-1"
  },"25": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Function Collisions/Clashing",
    "content": ". | https://github.com/tinchoabbate/function-clashing-poc | https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357 | https://docs.openzeppelin.com/sdk/2.5/pattern#transparent-proxies-and-function-clashes | . ",
    "url": "/docs/Security_Guide/#function-collisionsclashing",
    "relUrl": "/docs/Security_Guide/#function-collisionsclashing"
  },"26": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Testing procedure",
    "content": "To test for this vuln, you can approach it from angles XYZ… . ",
    "url": "/docs/Security_Guide/#testing-procedure-2",
    "relUrl": "/docs/Security_Guide/#testing-procedure-2"
  },"27": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "CTF Examples",
    "content": "Coming soon… . ",
    "url": "/docs/Security_Guide/#ctf-examples-2",
    "relUrl": "/docs/Security_Guide/#ctf-examples-2"
  },"28": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "CREATE2 contract replacement",
    "content": "Cannot be verified on etherscan?! Need to check on this. ",
    "url": "/docs/Security_Guide/#create2-contract-replacement",
    "relUrl": "/docs/Security_Guide/#create2-contract-replacement"
  },"29": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Testing procedure",
    "content": "To test for this vuln, you can approach it from angles XYZ… . ",
    "url": "/docs/Security_Guide/#testing-procedure-3",
    "relUrl": "/docs/Security_Guide/#testing-procedure-3"
  },"30": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "CTF Examples",
    "content": "Coming soon… . ",
    "url": "/docs/Security_Guide/#ctf-examples-3",
    "relUrl": "/docs/Security_Guide/#ctf-examples-3"
  },"31": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "OZ UUPS vuln",
    "content": ". | https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76 | https://www.iosiro.com/blog/openzeppelin-uups-proxy-vulnerability-disclosure | . ",
    "url": "/docs/Security_Guide/#oz-uups-vuln",
    "relUrl": "/docs/Security_Guide/#oz-uups-vuln"
  },"32": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Testing procedure",
    "content": "To test for this vuln, you can approach it from angles XYZ… . ",
    "url": "/docs/Security_Guide/#testing-procedure-4",
    "relUrl": "/docs/Security_Guide/#testing-procedure-4"
  },"33": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "CTF Examples",
    "content": "Coming soon… . ",
    "url": "/docs/Security_Guide/#ctf-examples-4",
    "relUrl": "/docs/Security_Guide/#ctf-examples-4"
  },"34": {
    "doc": "Security Guide to Proxy Vulns",
    "title": "Security Guide to Proxy Vulns",
    "content": "If you are unsure which proxy type is in the scope of your audit or security review, see the proxy identification flow chart. ",
    "url": "/docs/Security_Guide/",
    "relUrl": "/docs/Security_Guide/"
  },"35": {
    "doc": "yAcademy Proxies Research",
    "title": "yAcademy Proxies Research",
    "content": "Proxies are a powerful but often misdeployed component in smart contracts. This research effort compiled proxy knowledge with the goal of assisting with improving the correctness of proxy implementations and improving security audits involving proxies. This website is a work in progress. Please send any corrections or improvements to: hello AT yacademy DOT dev . ",
    "url": "/",
    "relUrl": "/"
  }
}
